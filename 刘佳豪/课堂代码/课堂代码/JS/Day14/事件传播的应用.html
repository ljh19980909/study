<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>事件传播的应用</title>
		<style type="text/css">
			* {
				margin: 0;
				padding: 0;
			}
			
			#div1 {
				width: 500px;
				height: 500px;
				background-color: red;
			}
			
			#div2 {
				width: 400px;
				height: 400px;
				background-color: yellow;
			}
			
			#div3 {
				width: 300px;
				height: 300px;
				background-color: blue;
			}
			
			#div4 {
				width: 200px;
				height: 200px;
				background-color: green;
			}
			
			#div5 {
				width: 100px;
				height: 100px;
				background-color: purple;
			}
			#box{
				width: 80px;
				height: 170px;
				border: red 2px solid;
			}
			#box>button{
				margin: 10px 0;
			}
		</style>
	</head>

	<body>
		<div id="div1">
			<div id="div2">
				<div id="div3">
					<div id="div4">
						<div id="div5"></div>
					</div>
				</div>
			</div>
		</div>
		<div id="box">
			<button>选项卡1</button><br />
			<button>选项卡2</button><br />
			<button>选项卡3</button><br />
			<button>选项卡4</button>
		</div>
		<script type="text/javascript">
			div1.onclick = function() {
				alert("这是div1");
			}
			div2.onclick = function() {
				alert("这是div2");
			}
			div3.onclick = function(e) {
				var even = e || event;
				even.stopPropagation();
				alert("这是div3");
			}
			div4.onclick = function() {
				alert("这是div4");
			}
			div5.onclick = function(e) {
//				var even = e || event;
//				even.stopPropagation();
				alert("这是div5");
			}
			/*
			 * 事件冒泡造成的问题:
			 * 直系继承树上如果存在相同的事件，默认因为有冒泡的特点，出发里面的，
			外面的将来也会触发，造成逻辑混乱。
			 * 解决办法:想办法阻止事件冒泡的传播。
			 * 
			 * 需要对应事件的事件对象去阻止事件的传播
			 * even.stopPropagation
			 * 
			 * IE的兼容性写法
			 * event.cancelBubble = true;
			 * 
			 * 事件冒泡的优势:
			 * "事件委托",利用了事件冒泡的特点，不给真正需要绑定事件的元素绑定事件，
			而是给这些元素的某个合适的祖先元素绑定事件，因为冒泡的特点，最终也会触发这个
			合适的祖先元素，达到简化代码的目的。
			 */
			box.onclick = function(){
				alert(111);
			}
		</script>
	</body>

</html>